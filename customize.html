<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Customize Your Order - Bead Haven</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background:#f9f5ff; color:#333; padding:30px; }
        .container { max-width:900px; margin:0 auto; background:#fff; padding:24px; border-radius:12px; box-shadow:0 6px 20px rgba(0,0,0,0.08); }
        h1{ color:#8a4fff; margin-bottom:6px }
        form { display:grid; grid-template-columns:1fr 320px; gap:20px }
        .col-full { grid-column: 1 / -1 }
        label { display:block; font-weight:600; margin-bottom:6px }
        input[type=text], input[type=email], textarea, select, input[type=number] { width:100%; padding:10px; border:1px solid #e7e2f8; border-radius:8px; }
        .materials { display:flex; flex-direction:column; gap:6px; }
        .preview { border:1px dashed #ddd; padding:10px; border-radius:8px; text-align:center; }
        img#imagePreview { max-width:100%; max-height:260px; display:block; margin:8px auto; }
        canvas#aiCanvas { max-width:100%; border-radius:8px; background:#fff; display:block; margin:8px auto }
        .preview-notice { margin-top:8px; font-size:0.95rem; color:#444; background:#fff6fb; border:1px solid #f3e7ff; padding:8px; border-radius:8px }
        .btn { display:inline-block; padding:10px 16px; border-radius:8px; background:#8a4fff; color:#fff; border:none; cursor:pointer; font-weight:700 }
        .secondary { background:#ff6b8b }
        .summary { white-space:pre-wrap; background:#faf7ff; padding:12px; border-radius:8px; border:1px solid #efe9ff; max-height:300px; overflow:auto }
        @media (max-width:900px) { form { grid-template-columns:1fr } }
    </style>
</head>
<body>
    <div class="container">
        <a href="Index.html">‚Üê Back to Shop</a>
        <h1>Customize Your Order</h1>
        <p>Upload your bead/style reference and choose preferred materials. This demo shows a preview and prepares an order payload you can send to your backend.</p>

        <form id="customForm">
            <div>
                <label for="name">Full Name</label>
                <input id="name" name="name" type="text" required>

                <label for="email" style="margin-top:12px">Email</label>
                <input id="email" name="email" type="email" required>

                <label for="style">Bead Style</label>
                <select id="style" name="style">
                    <option>Round</option>
                    <option>Faceted</option>
                    <option>Tube</option>
                    <option>Oval</option>
                    <option>Custom</option>
                </select>

                <label style="margin-top:12px">Preferred Materials</label>
                <div class="materials">
                    <label><input type="checkbox" name="materials" value="Glass"> Glass</label>
                    <label><input type="checkbox" name="materials" value="Crystal"> Crystal</label>
                    <label><input type="checkbox" name="materials" value="Wood"> Wood</label>
                    <label><input type="checkbox" name="materials" value="Stone"> Stone</label>
                    <label><input type="checkbox" name="materials" value="Metal"> Metal</label>
                    <label><input type="checkbox" name="materials" value="Leather"> Leather</label>
                </div>

                <label for="colors" style="margin-top:12px">Color Preferences</label>
                <input id="colors" name="colors" type="text" placeholder="e.g. Navy, Rose gold accents">

                <label for="quantity" style="margin-top:12px">Quantity</label>
                <input id="quantity" name="quantity" type="number" min="1" value="1">

                <label for="notes" style="margin-top:12px">Additional Notes</label>
                <textarea id="notes" name="notes" rows="4" placeholder="Any sizing, length, or special instructions"></textarea>

                <div style="margin-top:12px">
                    <button class="btn" type="submit">Prepare Order</button>
                    <button id="resetBtn" type="button" class="btn secondary" style="margin-left:8px">Reset</button>
                </div>
            </div>

            <div>
                <div class="col-full">
                    <label for="styleImage">Upload Reference Image</label>
                    <input id="styleImage" name="styleImage" type="file" accept="image/*">
                </div>

                <div class="preview">
                    <strong>Image Preview</strong>
                    <img id="imagePreview" alt="No image selected" style="display:none">
                    <canvas id="aiCanvas" width="800" height="800"></canvas>
                    <div id="previewNotice" class="preview-notice">This is a possible preview generated for preview purposes. Some items may be changed to retain product quality.</div>
                    <div style="margin-top:8px">
                        <button id="generatePreviewBtn" class="btn" type="button">Generate AI Preview</button>
                        <span id="previewLoading" style="display:none;margin-left:10px">Generating preview...</span>
                    </div>
                </div>

                <div style="margin-top:12px">
                    <label>Order Summary</label>
                    <div id="orderSummary" class="summary">No order prepared yet.</div>
                </div>

                <div style="margin-top:10px; display:flex; gap:8px; align-items:center">
                    <a id="chatSupport" class="btn" href="#" target="_blank" rel="noopener">Chat with Support</a>
                    <a id="sendEmail" class="btn secondary" style="text-decoration:none; display:inline-flex; align-items:center; justify-content:center" href="#">Email Order</a>
                </div>
            </div>
        </form>
    </div>

    <script>
        const styleImage = document.getElementById('styleImage');
        const imagePreview = document.getElementById('imagePreview');
        const form = document.getElementById('customForm');
        const summary = document.getElementById('orderSummary');
        const chatSupportBtn = document.getElementById('chatSupport');
        const sendEmail = document.getElementById('sendEmail');
        const resetBtn = document.getElementById('resetBtn');

        let lastOrderPayload = null;

        styleImage.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) { imagePreview.src = ''; imagePreview.alt = 'No image selected'; return }
            const reader = new FileReader();
            reader.onload = () => {
                imagePreview.src = reader.result;
                imagePreview.alt = file.name;
            };
            reader.readAsDataURL(file);
        });

        form.addEventListener('submit', async (e) => {
            e.preventDefault();

            const formData = new FormData(form);

            const materials = [];
            for (const val of formData.getAll('materials')) materials.push(val);

            const order = {
                name: formData.get('name') || '',
                email: formData.get('email') || '',
                style: formData.get('style') || '',
                materials,
                colors: formData.get('colors') || '',
                quantity: parseInt(formData.get('quantity') || '1', 10),
                notes: formData.get('notes') || '',
                timestamp: new Date().toISOString()
            };

            const file = styleImage.files[0];
            if (file) {
                order.imageName = file.name;
                order.imageType = file.type;
                // include base64 data for demo/backends that accept it
                order.imageData = await readFileAsDataURL(file);
            }

            lastOrderPayload = order;
            summary.textContent = JSON.stringify(order, null, 2);

            // Prepare WhatsApp chat link for support (replace phone if you want a different number)
            const supportNumber = '2349059780623';
            const waMessage = `Custom Order from ${order.name || 'Customer'}\n\nStyle: ${order.style || ''}\nMaterials: ${order.materials.join(', ') || ''}\nColors: ${order.colors || ''}\nQuantity: ${order.quantity}\nNotes: ${order.notes || ''}\n\n${order.imageData ? 'Image included (sent separately).' : ''}\n\nOrder time: ${order.timestamp}`;
            chatSupportBtn.href = `https://api.whatsapp.com/send?phone=${supportNumber}&text=${encodeURIComponent(waMessage)}`;
            chatSupportBtn.target = '_blank';

            // Prepare mailto (note: base64 usually too large for mailto; we include summary only)
            const mailBody = encodeURIComponent(JSON.stringify({ ...order, imageData: order.imageData ? '[image included]' : null }, null, 2));
            sendEmail.href = `mailto:${encodeURIComponent(order.email || '')}?subject=${encodeURIComponent('Custom Bead Order')}&body=${mailBody}`;
        });

        resetBtn.addEventListener('click', () => {
            form.reset();
            imagePreview.src = '';
            imagePreview.alt = 'No image selected';
            summary.textContent = 'No order prepared yet.';
            lastOrderPayload = null;
        });

        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const r = new FileReader();
                r.onload = () => resolve(r.result);
                r.onerror = () => reject(new Error('Failed to read file'));
                r.readAsDataURL(file);
            });
        }

        function downloadJSON(obj, filename) {
            const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
        }

        // --- AI Preview generation ---
        const generateBtn = document.getElementById('generatePreviewBtn');
        const aiCanvas = document.getElementById('aiCanvas');
        const previewLoading = document.getElementById('previewLoading');
        const apiEndpointInput = document.getElementById('apiEndpoint');
        const apiKeyInput = document.getElementById('apiKey');

        generateBtn.addEventListener('click', async () => {
            // gather current form data (reuse logic from submit)
            const formData = new FormData(form);
            const materials = formData.getAll('materials');
            const payload = {
                name: formData.get('name') || '',
                style: formData.get('style') || '',
                materials,
                colors: formData.get('colors') || '',
                quantity: parseInt(formData.get('quantity') || '1', 10),
                notes: formData.get('notes') || ''
            };

            // include image if present
            const file = styleImage.files[0];
            if (file) {
                payload.imageName = file.name;
                payload.imageType = file.type;
                payload.imageData = await readFileAsDataURL(file);
            }

            previewLoading.style.display = 'inline';
            generateBtn.disabled = true;

            try {
                // If user provided an API endpoint, attempt to call it.
                const endpoint = apiEndpointInput ? apiEndpointInput.value.trim() : '';
                if (endpoint) {
                    const result = await callAIPreviewEndpoint(endpoint, apiKeyInput ? apiKeyInput.value.trim() : '', payload);
                    if (result && result.previewUrl) {
                        await drawImageUrlToCanvas(result.previewUrl, aiCanvas);
                    } else if (result && result.previewData) {
                        await drawDataUrlToCanvas(result.previewData, aiCanvas);
                    } else {
                        // fallback to mock if API didn't return usable preview
                        await mockGeneratePreview(payload, aiCanvas);
                    }
                } else {
                    // no API configured -> mock preview
                    await mockGeneratePreview(payload, aiCanvas);
                }
            } catch (err) {
                console.error('Preview generation failed:', err);
                await mockGeneratePreview(payload, aiCanvas);
            } finally {
                previewLoading.style.display = 'none';
                generateBtn.disabled = false;
            }
        });

        async function callAIPreviewEndpoint(endpoint, apiKey, payload) {
            // Expecting endpoint to accept JSON {payload} and return { previewUrl | previewData }
            try {
                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(apiKey ? { 'Authorization': apiKey } : {})
                    },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) throw new Error('AI API responded with status ' + res.status);
                return await res.json();
            } catch (err) {
                console.error('AI API call failed', err);
                throw err;
            }
        }

        function drawImageUrlToCanvas(url, canvas) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    fitImageToCanvas(img, canvas);
                    resolve();
                };
                img.onerror = reject;
                img.src = url;
            });
        }

        function drawDataUrlToCanvas(dataUrl, canvas) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => { fitImageToCanvas(img, canvas); resolve(); };
                img.onerror = reject;
                img.src = dataUrl;
            });
        }

        function fitImageToCanvas(img, canvas) {
            const ctx = canvas.getContext('2d');
            // size canvas to image aspect (limit max dimension)
            const maxDim = 1000;
            let w = img.width, h = img.height;
            const scale = Math.min(maxDim / Math.max(w, h), 1);
            w = Math.round(w * scale); h = Math.round(h * scale);
            canvas.width = w; canvas.height = h;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        }

        // Mock preview: compose uploaded image (if any) with simple bead shapes and labels
        async function mockGeneratePreview(order, canvas) {
            return new Promise(async (resolve) => {
                // small delay to simulate generation
                await new Promise(r => setTimeout(r, 800));

                const ctx = canvas.getContext('2d');
                const size = 800;
                canvas.width = size; canvas.height = size;

                // background gradient
                const g = ctx.createLinearGradient(0,0,size,size);
                g.addColorStop(0, '#fff');
                g.addColorStop(1, '#f7f0ff');
                ctx.fillStyle = g;
                ctx.fillRect(0,0,size,size);

                // draw uploaded image faded in center if present
                if (order.imageData) {
                    const img = new Image();
                    img.src = order.imageData;
                    await new Promise((res) => { img.onload = res; img.onerror = res; });
                    // compute fit
                    const iw = img.width, ih = img.height;
                    const maxW = size * 0.9, maxH = size * 0.45;
                    const scale = Math.min(maxW / iw, maxH / ih, 1);
                    const dw = iw * scale, dh = ih * scale;
                    const dx = (size - dw) / 2, dy = size * 0.08;
                    ctx.globalAlpha = 0.9;
                    ctx.drawImage(img, dx, dy, dw, dh);
                    ctx.globalAlpha = 1.0;
                }

                // draw bead mock: rows of circles colored by selected colors/materials
                const colors = parseColorPreferences(order.colors);
                const mats = order.materials && order.materials.length ? order.materials : ['Glass'];
                const startY = size * 0.6;
                const radius = 28;
                const gap = 18;
                const cols = Math.min(8, Math.max(3, Math.ceil(mats.length + colors.length)));
                let x = (size - (cols * (radius*2 + gap) - gap)) / 2 + radius;
                let y = startY + radius;

                // draw up to cols beads
                for (let i=0;i<cols;i++) {
                    const c = colors[i % colors.length] || '#d9b3ff';
                    ctx.beginPath(); ctx.fillStyle = c; ctx.arc(x + i*(radius*2+gap), y, radius, 0, Math.PI*2); ctx.fill();
                    ctx.lineWidth = 2; ctx.strokeStyle = '#ffffff88'; ctx.stroke();
                }

                // draw labels
                ctx.fillStyle = '#333'; ctx.font = '600 20px "Segoe UI"';
                ctx.fillText(order.style || 'Style: Custom', 24, size - 80);
                ctx.font = '14px "Segoe UI"';
                ctx.fillText('Materials: ' + (mats.join(', ') || 'Glass'), 24, size - 54);
                ctx.fillText('Note: This is a preview. Final product may vary to retain quality.', 24, size - 28);

                resolve();
            });
        }

        function parseColorPreferences(text) {
            if (!text) return ['#8a4fff', '#ff6b8b', '#ffd27f'];
            // try to extract words that look like color names or hex codes
            const parts = text.split(/[,;|\/]+/).map(s => s.trim()).filter(Boolean);
            // map some common color names to hex
            const map = { red:'#ff4d4f', blue:'#4d79ff', navy:'#16324f', pink:'#ff6b8b', gold:'#ffd27f', rose:'#ffb3c6' };
            const out = parts.map(p => map[p.toLowerCase()] || (p.startsWith('#') ? p : null)).filter(Boolean);
            return out.length ? out : ['#8a4fff', '#ff6b8b'];
        }

    </script>
</body>
</html>
